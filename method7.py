import math # импортируем модуль math для использования математических функций

n = 20 # задаем количество узлов интерполяции
a = 0 # задаем начальную точку интервала
b = 4 # задаем конечную точку интервала

# Функция, для которой мы хотим провести интерполяцию
def f(x):
    return 1 / (1 + math.exp(-x)) # определяем функцию, для которой будем проводить интерполяцию

# Вычисляем шаг
h = (b - a) / (n - 1) # вычисляем шаг между узлами

# Генерируем равномерно распределенные узлы
x = [a + i * h for i in range(n)] # генерируем список узлов интерполяции
fx = [f(xi) for xi in x] # генерируем список значений функции в узлах

# Функция для выполнения кубической сплайн-интерполяции
def Spline(x, fx):
    n = len(x) # определяем количество узлов интерполяции
    h = [x[i + 1] - x[i] for i in range(n - 1)] # вычисляем расстояние между соседними узлами
    alpha = [(3 / h[i]) * (fx[i + 1] - fx[i]) - (3 / h[i - 1]) * (fx[i] - fx[i - 1]) for i in range(1, n - 1)] # вычисляем коэффициенты alpha
    l = [1] + [0] * (n - 2) # создаем список l, первый элемент которого равен 1, а остальные - 0
    mu = [0] * n # создаем список mu, заполненный нулями
    z = [0] * n # создаем список z, заполненный нулями
    c = [0] * n # создаем список c, заполненный нулями
    b1 = [0] * n # создаем список b1, заполненный нулями
    d = [0] * n # создаем список d, заполненный нулями
    a1 = fx[:] # создаем копию списка значений функции в узлах

    for i in range(1, n - 1):
        l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1] # вычисляем значения l
        mu[i] = h[i] / l[i] # вычисляем значения mu
        z[i] = (alpha[i-1] - h[i - 1] * z[i - 1]) / l[i] # вычисляем значения z

    c[n - 1] = 0 # задаем последний элемент списка c равным 0
    z[n - 1] = 0 # задаем последний элемент списка z равным 0

    for j in range(n - 2, -1, -1):
        c[j] = z[j] - mu[j] * c[j + 1] # вычисляем значения c
        b1[j] = (fx[j + 1] - fx[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3 # вычисляем значения b1
        d[j] = (c[j + 1] - c[j]) / (3 * h[j]) # вычисляем значения d

    # Функция для вычисления значений сплайна в заданных точках
    def S(xi):
        for i in range(n - 1):
            if xi >= x[i] and xi <= x[i + 1]:
                dx = xi - x[i] # вычисляем расстояние между заданной точкой и ближайшим узлом интерполяции
                return a1[i] + b1[i] * dx + c[i] * (dx**2) + d[i] * (dx**3) # вычисляем значение сплайна в заданной точке
        return None

    return S # возвращаем функцию S, которая позволяет вычислять значения сплайна в заданных точках

# Вычисляем кубический сплайн
S = Spline(x, fx) # вычисляем кубический сплайн

# Получаем промежуточные значения в узлах
Points = [S(a + h / 2 + i * h) for i in range(n - 1)] # вычисляем значения сплайна в промежуточных точках

# Выводим результаты
for i in range(n - 1):
    xi = a + h / 2 + i * h # определяем значение x в промежуточных точках
    Value = f(xi) # вычисляем значение функции в промежуточных точках
    print(f"x(i + 1) = xi, S(x) = Points[i], Точное значение = Value") # выводим результаты интерполяции для каждой промежуточной точки





import math
n = 20
a = 0
b = 4
# Функция, для которой мы хотим провести интерполяцию
def f(x):
    return 1 / (1 + math.exp(-x))

# Вычисляем шаг
h = (b - a) / (n - 1)

# Генерируем равномерно распределенные узлы
x = [a + i * h for i in range(n)]
fx = [f(xi) for xi in x]

# Функция для выполнения кубической сплайн-интерполяции
def Spline(x, fx):
    n = len(x)
    h = [x[i + 1] - x[i] for i in range(n - 1)]
    alpha = [(3 / h[i]) * (fx[i + 1] - fx[i]) - (3 / h[i - 1]) * (fx[i] - fx[i - 1]) for i in range(1, n - 1)]
    l = [1] + [0] * (n - 2)
    mu = [0] * n
    z = [0] * n
    c = [0] * n
    b1 = [0] * n
    d = [0] * n
    a1 = fx[:]

    for i in range(1, n - 1):
        l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1]
        mu[i] = h[i] / l[i]
        z[i] = (alpha[i-1] - h[i - 1] * z[i - 1]) / l[i]

    c[n - 1] = 0
    z[n - 1] = 0

    for j in range(n - 2, -1, -1):
        c[j] = z[j] - mu[j] * c[j + 1]
        b1[j] = (fx[j + 1] - fx[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3
        d[j] = (c[j + 1] - c[j]) / (3 * h[j])

    # Функция для вычисления значений сплайна в заданных точках
    def S(xi):
        for i in range(n - 1):
            if xi >= x[i] and xi <= x[i + 1]:
                dx = xi - x[i]
                return a1[i] + b1[i] * dx + c[i] * (dx**2) + d[i] * (dx**3)
        return None

    return S

# Вычисляем кубический сплайн
S = Spline(x, fx)

# Получаем промежуточные значения в узлах
Points = [S(a + h / 2 + i * h) for i in range(n - 1)]

# Выводим результаты
for i in range(n - 1):
    xi = a + h / 2 + i * h
    Value = f(xi)
    print(f"x({i + 1}) = {xi}, S(x) = {Points[i]}, Точное значение = {Value}")